# Module Loading

## Packages
The files in these directories are loaded via the [`use-package`](https://github.com/jwiegley/use-package) package.

### Use Package Usage
#### Cheat Sheet

- `:init` - Executes _before_ a package is loaded.
    - All forms up until next keyword are evaluated.
    - Always executed, whethor or not module is loaded.
    - Restrict to code that will always succeed.
- `:config` - Executes _after_ a package is loaded.
    - All forms up until next keyword are evaluated.
    - If loading lazily, execution is deferred until after autoload occurs.
- `:bind` - Binds keys to commands.
    - Creates an autoload for the command, defers loading of module until used.
    - Creates binding to that command.
    - Similar to using `bind-key` in the `:init` block.
    - Use `M-x describe-personal-keybindings` to see all such keybindings.
    - Takes a cons or a list conses.
    - Example: `:bind ("C-." . command)` or `:bind (("C-." . command1) ("C-," . command2))`.
- `:bind-keymap` - Binds keys to keymaps
    - For cases where you want a keybinding to function as a prefix to keymap (i.e. not a function)
- `:bind (:map <command-map> ...(bindings))` - Adds new bindings to a local keymap in the module
- `:commands` - Creates autoloads for the commands, defers loading of module until commands are used.
    - Takes either a symbol or a list of symbols.
    - Example: `:commands command` or `:commands (command1 command2)`
- `:mode` - Establish a deferred binding within the `auto-mode-alist`
    - Example: `:mode ("\\.py\\'" . python-mode)`
- `:interpreter` - Establish a deferred binding within the `interpreter-mode-alist`
    - Example: `:interpreter ("python . python-mode")`
- `:hook` - Allows adding functions onto hooks.
    - Only basename of hook is required.
    - The following examples are equivalent
        - `(use-package ace-jump-mode :hook prog-mode)`
        - `(use-package ace-jump-mode :hook (prog-mode . ace-jump-mode))`
        - `(use-package :commands ace-jump-mode :init (add-hook 'prog-mode-hook #'ace-jump-mode))`
    - When multiple hooks are needed, the following are equivalent:
        - `:hook (prog-mode text-mode)`
        - `:hook ((prog-mode text-mode) . ace-jump-mode)`
        - `:commands ace-jump-mode :init (add-hook 'prog-mode-hook #'ace-jump-mode) (add-hook 'text-mode-hook #'ace-jump-mode)`
- `:defer` - Defers loading module until used.
    - `:commands`, `:bind`, `:bind*`, `:bind-keymap`, `:bind-keymap*`, `:mode`, `:interpreter`, and `:hook` all imply `:defer`
    - Accepts number, waits N seconds to load module
    - Example: `(use-package ace-jump-mode :defer t :init (autoload 'ace-jump-mode "ace-jump-mode" nil t) (bind-key "C-." 'ace-jump-mode))`
    - Is equivalent to: `(use-package ace-jump-mode :bind ("C-." . ace-jump-mode))`
- `:custom` - Allows customization of package custom variables
    - Example: `:custom (some-var-name 200 "This var does a thing")`
    - The documentation string is optional
- `:demand` - Forces loading of a module immediately, overrides `:defer` whether set explicitly or implied.
- `:if` - Conditionally load / initialize modules.
    - `:when` - alias for `:if`
    - `:unless` - `:if (not foo)`
    - Example: `:if window-system :config ...`
    - Example: `:if (memq window-system '(mac ns)) :config ...`
- `:disabled` - Turn off a module or stop loading something you're not using
- `:after ` - Delays loading of a package until dependencies are loaded
    - Supports `:all`, `:any`
    - By default, implicit `:all`
    - Examples:
      - `:after (foo bar)`
      - `:after (:all foo bar)`
      - `:after (:any foo bar)`
      - `:after (:all (:any foo bar) (:any baz quux))`
      - `:after (:any (:all foo bar) (:all baz quux))`
- `:require` - Doesn't load a package if dependencies are not available
    - Example: `:requires foo` or `:requires (foo bar baz)`
- `:defines` - Declare dummy variables for the sake of the byte-compiler
- `:functions` - Declare dummy function declarations for the sake of the byte-compiler
- `:no-require t` - Don't load the package
- `:load-path` - Add a directory to the load path for this function.
    - Accepts a symbol, function, string, or list of strings.
    - Relative paths are expanded with `user-emacs-directory`
- `:catch` - Handle errors during package expansion
    - Setting to `t` or `nil` enables or disables catching errors at load time
    - Also accepts a function with two parameters: the keyword being processed, and the error object.
    - Error object is generated by `condition-case`
    - Example: `:catch (lambda (keyword err) (message (error-message-string err)))`
- `:diminish` - Remove or modify minor mode strings in the mode-line
    - Accepts a minor mode symbol, a cons of the mode and its replacement, a string for the replacement
    - In the case of the string, the mode is assumed to be package name with `-mode` appended
- `:delight` - Remove or modify minor mode strings in the mode-line
    - Accepts a minor mode symbol, a replacement string or quoted mode-line data, both, or lists of both.
    - If no argument, minor mode is hidden completely from mode-line
- `:ensure t` - Install package via `package.el` if not already present
    - By default, `package.el` prefers `melpa` over `melpa-stable`
    - Can use `:pin` to force specific archive. Use archive `manual` to force manually installed version and ignore upstream.
    - Archives must exist in `package-archives`
  
#### Longer `:catch` Example

``` emacs-lisp
(use-package example
  ;; Note that errors are never trapped in the preface, since doing so would
  ;; hide definitions from the byte-compiler.
  :preface (message "I'm here at byte-compile and load time.")
  :init (message "I'm always here at startup")
  :config
  (message "I'm always here after the package is loaded")
  (error "oops")
  ;; Don't try to (require 'example), this is just an example!
  :no-require t
  :catch (lambda (keyword err)
           (message (error-message-string err))))
```

#### About Package Loads
When a package is loaded, and if you have `use-package-verbose` set to `t`, or if the package takes longer than 0.1s to load, you will see a message to indicate this loading activity in the `*Messages*` buffer. The same will happen for configuration, or `:config` blocks that take longer than 0.1s to execute. In general, you should keep `:init` forms as simple and quick as possible, and put as much as you can get away with into the `:config` block. This way, deferred loading can help your Emacs to start as quickly as possible.

Additionally, if an error occurs while initializing or configuring a package, this will not stop your Emacs from loading. Rather, the error will be captured by `use-package`, and reported to a special `*Warnings*` popup buffer, so that you can debug the situation in an otherwise functional Emacs.

#### Available Options
- `use-package-verbose` - Verbose output when expanding packages.
- `use-package-always-defer` - Always defer package loading.
- `use-package-expand-minimally` - Setting to `t` disables catching and reporting of errors.
- `use-package-always-ensure` - Always `:ensure t` all packages.
- `use-package-always-pin` - Set a default `:pin` archive.
- `use-package-compute-statistics` - Enable to make statistics available.
  - Enable after `use-package` is loaded, but before any `use-package` forms.
  - See the statistics with `M-x use-package-report`.
  - Use `S` in a column to sort the rows based on it.
  
#### Useful Extensions
- `use-package-ensure-system-package`
- `use-package-chords`
